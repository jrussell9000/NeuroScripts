#! /usr/bin/env python


"""
       %prog     [options] input_motion_values.1D
           interactive review of motion plots
       %prog -f  [options] input_motion_values.1D
           non-interactive; write out censor info and demeaned motion
       %prog -ff [options] input_motion_values.1D
           just write out demeaned motion

Graphical interface to simplify the inspection and censoring of the fMRI
motion data resulting from motion correction.  Also writes out demeaned
motion covariates.  (Use -ff option if this is all you want.)

First reads through a motion .1D file generated by AFNI program 3dvolreg and
detects spikes using a simple algorithm.  Plots of motion are displayed with
auto-censored points highlighted.  Overall drifts are displayed and
excessive drifts are highlighted.  After inspection and manual censoring (if
desired) the "Done" button will write out a censor file with 0 for censored
points and 1 everywhere else; a list of which TRs were censored; and a
demeaned version of the input motion values.  You may suppress the censor
outputs with -i, or suppress all outputs with -ii (except the Reject file,
as described below.)

The motion plots are centered for display purposes, but the axes are labeled
correctly.  The 'Scale' button cycles through different magnification levels
for the graphs.  The 'SepScale/SameScal' button controls whether each graph
is scaled separately, or whether each group of three graphs of the same type
(i.e., three rotation graphs and three translation graphs) are scaled
together for ease of comparison.  Note that rotation graphs and translation
graphs are measuring different units, namely degrees and millimeters, and so
they can not be scaled the same.  

The smallest tick-marks indicate 0.25, the medium ones indicate 0.5, and
the longest indicate 1.0.  At no time will the graphs be displayed with
resolution greater than 1 total from  top to bottom.  This is to avoid
making tiny movements appear significant.

The left side of the window displays the current TR under the cursor; the 
number of TRs currently censored; the ratio of TRs currently censored; the
value of each of the 6 motion parameters at the point under the cursor; and
the overall drift in each axis, not counting points that were auto-censored.
Drifts and censor ratio are highlighted if they are over the maximum values
specified by command line options (or defaults).

The "Reject" button causes the program to write out a file in the current
working directory, with the same name as the input file, plus a suffix 
"_REJECT".  This file could then be used by downstream scripts to recognize
that this scan run has been rejected due to excessive motion.  When this
file is present, the axis scale of the graphs will be highlighted in red
as a warning and the "Reject" button will change to an "Accept" button.

The REJECTED flag file is written at the moment the "Reject" button is
clicked.  Other than that, output files are written at quit time.  In
summary:

--The censor file, as described above.
--A list of the indices of the censored points, with the suffix
    _censorlist.txt.
--The demeaned motion data is written out as a 6-column .1D file.  Note that
  the motion output from 3dvolreg will have 9 or 6 columns depending on the
  options used, but output from this program will have only the 6 motion
  columns, so adjust your indices accordingly.

To quit without writing out any of these files, use the "Cancel" button.
Note that all outputs will overwrite by default.  I might change this if
there is enough demand for a safety mechanism in this regard.

Notes:
--Do not demean motion values that have already been concatenated;
this will defeat the purpose of demeaning.  Inspect and demean motion using
this program first, then concatenate demeaned motion values.

--The translation and rotation thresholds specified with -t and -r, and the
before- and after-skip values specified with -b and -a (or the defaults)
control the auto-censoring algorithm.  The rest of the maximum-value options
only control how the program notifies you of extreme values, they do not
affect the output.
"""

ID = "$Id"[1:-1]

version="censor.py by David M. Perlman 2008-04-24 version 1.01"

    
######################## Default values for options ########################

tthresh_def         =0.9            # mm threshold for censoring in translation
rthresh_def         =0.9            # deg threshold for censoring in rotation
bskip_def           =1              # num points to skip before a discontinuity
askip_def           =2              # num points to skip after a discontinuity
tdrift_def          =5.0            # max mm translation drift before flagging
rdrift_def          =5.0            # max deg rotation drift before flagging
maxcens_def         =0.3            # max fraction of points censored before flagging
demeansuffix_def    ="_demean.1D"
censorsuffix_def    ="_censor.1D"
censorlistsuffix_def="_censorlist.txt"
rejectsuffix_def    ="_REJECT"
plotheight_def      =600

######################## Other default values###############################
# These are added to the data.options from optionparser.

scalewidth = 25
censheight = 5              # the height of the plot of the censor series
censbasepix = 10  
scale_each_click = 1.5      # how much to expand the scale with each click of scale button
num_scales = 5              # how many levels of scale to cycle through

############################################################################


from Tkinter import *
from copy import deepcopy
from optparse import OptionParser
import tkMessageBox as tkm
import os
# these are just for debugging
#import sys, traceback

 

def main():
    data = Data()
    
    # set up options
    description = __doc__
    parser = OptionParser(usage=__doc__, version=version)
    
    #parser.add_option("-h", "--help", action="callback", callback=help_function)
    
    ## Add options for censoring parameters
    parser.add_option("-t", "--translation-thresh", dest="tthresh", type="float", default=tthresh_def, 
          help="Discontinuity threshold for translation in millimeters.  Default: %f" % tthresh_def, metavar="MM_VAL")

    parser.add_option("-r", "--rotation-thresh", dest="rthresh", type="float", default=rthresh_def, 
          help="Discontinuity threshold for rotation in degrees.  Default: %f" % rthresh_def, metavar="DEG_VAL")

    parser.add_option("-b", "--before-skip", dest="bskip", type="int", default=bskip_def, 
          help="Number of points to skip BEFORE a discontinuity.  Default: %d" % bskip_def, metavar="NUM_POINTS")

    parser.add_option("-a", "--after-skip", dest="askip", type="int", default=askip_def, 
          help="Number of points to skip AFTER a discontinuity.  Default: %d" % askip_def, metavar="NUM_POINTS")

    parser.add_option("-d", "--translation-maxdrift", dest="tdrift", type="float", default=tdrift_def, 
          help="Maximum allowed overall translation in any axis.  Default: %f" % tdrift_def, metavar="MM_VAL")

    parser.add_option("-e", "--rotation-maxdrift", dest="rdrift", type="float", default=rdrift_def, 
          help="Maximum allowed overall rotation in any axis.  Default: %f" % rdrift_def, metavar="DEG_VAL")

    parser.add_option("-m", "--max-fraction", dest="maxcens", type="float", default=maxcens_def, 
          help="Maximum allowed fraction of points censored (must be between 0 and 1).  Default: %f" % maxcens_def, metavar="FRACTION")

    parser.add_option("-f", "--force-no-interactive", dest="nointeractive", action="count", default=0, 
          help="Just run the algorithm and write out the results, no interactive graphs.  Use -ff to write out only the demeaned motion.")

    parser.add_option("-i", "--interactive-only", dest="interactive", action="count", default=0, 
          help="Run the program but do not write out any censor information.  Use -ii to supress writing of demeaned motion too.")

    ## Add options for input and output

    parser.add_option("-c", "--censor-input", dest="censorin", type="string", 
          help="An existing censor file to view and edit instead of the automatically generated one.", metavar="CENS_FILE")

    parser.add_option("--demean-suffix", dest="demeansuffix", type="string", default=demeansuffix_def, 
          help="Suffix to append to filename for demeaned motion values.  Default: " + demeansuffix_def, metavar="DEMEAN_SUFF")

    parser.add_option("--censor-suffix", dest="censorsuffix", type="string", default=censorsuffix_def, 
          help="Suffix to append to filename for output censor file.  Default: " + censorsuffix_def, metavar="CENSOR_SUFF")

    parser.add_option("--censorlist-suffix", dest="censorlistsuffix", type="string", default=censorlistsuffix_def, 
          help="Suffix to append to filename for output list of censored points.  Default: " + censorlistsuffix_def, metavar="CENSORLIST_SUFF")

    parser.add_option("--reject-suffix", dest="rejectsuffix", type="string", default=rejectsuffix_def, 
          help="Suffix to append to filename for REJECT flag file.  Default: " + rejectsuffix_def, metavar="REJECT_SUFF")
    
    ## Miscellaneous low-priority options
    
    parser.add_option("--plots-height", dest="plotheight", type="int", default=plotheight_def, 
          help="Height of the total plot area in pixels.  Default: %d" % plotheight_def, metavar="PIXELS")




    (data.options, args) = parser.parse_args()
    
    if len(args) != 1:
        parser.error("Requires exactly one input file argument.")
        
    if (data.options.nointeractive > 0) & (data.options.interactive > 0):
        parser.error("-f and -i options are mutually exclusive!")
        
    if not 0 < data.options.maxcens < 1:
        parser.error("-m option: Maximum censor fraction must be between 0 and 1.")
    
    # Also add non-changeable parameters to options so they can be accessed by the UI
    data.options.scalewidth  = scalewidth
    data.options.censbasepix = censbasepix
    data.options.censheight  = censheight
    data.options.scale_each_click = scale_each_click
    data.options.num_scales = num_scales
    
    # And add some other info for them too
    data.inputname  = os.path.abspath(args[0])
    data.censorname = os.path.splitext(os.path.abspath(args[0]))[0] + data.options.censorsuffix
    data.censorlist = os.path.splitext(os.path.abspath(args[0]))[0] + data.options.censorlistsuffix
    data.demeanname = os.path.splitext(os.path.abspath(args[0]))[0] + data.options.demeansuffix
    data.rejectname = os.path.splitext(os.path.abspath(args[0]))[0] + data.options.rejectsuffix

        
    try:
        #print "Loading motion file:", args[0]
        motdatbig=zip(*load(args[0]))
    except:
        #print formatExceptionInfo()
        parser.error("Couldn't read motion file %s" % args[0])
            
    c, data.r = shape(motdatbig)
    
    if c == 9:
        data.motdat=motdatbig[1:7]
    elif c == 6:
        data.motdat=motdatbig
    else:
        parser.error("Wrong number of columns: $d" % c)

    # free up that memory like a good citizen
    del(motdatbig)
    
    # for debugging: replace one with a ramp
    #data.motdat[0]=[3*i/float(data.r) for i in range(data.r)]
    
    
    if data.options.censorin:
        # read in a censor file
        try:
            data.censseries=list(zip(*load(data.options.censorin))[0])
            # need to zip it because load puts each line in a separate list
            #print "censor shape, type:", shape(censseries), type(censseries)
        except:
            parser.error("Couldn't read input censor file %s" % data.options.censorin)
    else:
        # generate the censor, using the options stored under "data"
        data.censseries = calc_censor(data.motdat, data)
        # since we created something new, we want to save it, unless otherwise specified
        yes_save = True

    if len(data.censseries) != shape(data.motdat)[1]:
        parser.error("Input censor file is the wrong size or shape!\n" +
               "Must be one column of numbers with same length as the motion data.")
    

    # now collect some stats: # censored, ratio censored
    data.censedn = data.censseries.count(0)
    data.censedr = float(data.censedn)/float(data.r)
    print "Trans. thresh: %f Rot. thresh: %f" % (data.options.tthresh, data.options.rthresh)
    print "Censored: %d Censored ratio: %f" % (data.censedn, data.censedr)
    
    
    # Total overall drift, after removing the censored points
    # Note that since it's demeaned, multiplying the motion series
    # by the censseries sets the censored points to the mean, which means
    # they won't affect the drift.  Otherwise zero might be an extreme value.
    # May want to add smoothing to this check at some point, but probably not.
    
    # get the columnwise means (result: 6 vals)
    data.mot_means = meanbycol(data.motdat)
    
    # demean the data (makes display easier, will write this out later for convenience, too.)
    data.mot_demean = subtractbyrow(data.motdat, data.mot_means)
    
    # get the columnwise raw drifts, including spike amplitude
    # zip it because we're only using it for the max-min difference 
    motsort = zip(*sortbycol(data.motdat))
    data.maxdrift = subtracteach(motsort[-1], motsort[0])
    
    # get the columnwise raw centers, including spike amplitude
    data.centers = smult(addeach(motsort[-1], motsort[0]), 0.5)
    
    # get the raw centered version of the data
    data.mot_centered = subtractbyrow(data.motdat, data.centers)
    
    # get the columnwise valid drifts, not counting spikes
    # in order for censoring to work, data must be centered or demeaned, so that 
    # zero is guaranteed to not be an extreme value.
    # take out the centers and sort
    motsort_c = sortbycol(multeachbycol(data.censseries, data.mot_centered))
    # put the centers back in so we now have data censored to the center
    motsort_c = zip(*addbyrow(motsort_c, data.centers))
    #print "High:    % 7.3f % 7.3f % 7.3f % 7.3f % 7.3f % 7.3f" % tuple(motsort_c[-1])  
    #print "Low::    % 7.3f % 7.3f % 7.3f % 7.3f % 7.3f % 7.3f" % tuple(motsort_c[0])
    #print "Cntr:    % 7.3f % 7.3f % 7.3f % 7.3f % 7.3f % 7.3f" % tuple(data.centers)
    data.maxdrift_c = subtracteach(motsort_c[-1], motsort_c[0])
    
    # get the columnwise valid centers, IGNORING spike amplitude
    data.centers_c = smult(addeach(motsort_c[-1], motsort_c[0]), 0.5)
    
    # get the non-spike-including centered version of the data
    data.mot_centered_c = subtractbyrow(data.motdat, data.centers_c)
    
    ##### If for some reason every point is centered, we get a div-by-zero 
    # later when using the maxdrift for the censored data (which is zero, of course.)
    cleanup_zero_drifts(data)
    
    
    del(motsort)
    del(motsort_c)

    # make immutable backup for the revert button
    data.censbackup=tuple(deepcopy(data.censseries))
    
    ###########################################################
    # run the UI with the version of the data that we want
    
    if data.options.nointeractive == 0: yes_save = make_interactive_graphs(data.mot_centered, data.centers, data, parser)
    
    ###########################################################
    
    
    # now we're done playing, write out the censor file and the demeaned data if desired
    if yes_save:
        try:
            if (data.options.nointeractive < 2) & (data.options.interactive < 1): save(data.censorname, zip(data.censseries), '%d')
            # zip it to get it as a column
        except:
            parser.error("Couldn't save censor file %s" % data.censorname)
        
        try:
            if (data.options.nointeractive < 2) & (data.options.interactive < 1): save(data.censorlist, zip(findall(data.censseries,0)), '%d')
            # zip it to get it as a column
        except:
            parser.error("Couldn't save list of censored points %s" % data.censorlist)
        
        try:
            if data.options.interactive < 2: save(data.demeanname, zip(*data.mot_demean), ' % 9.6f ')
        except:
            parser.error("Couldn't save demeaned motion file %s" % data.demeanname)
    
        
    
    
###########################################################
#Function definitions.
###########################################################


def flag_for_rejection(data, reject=TRUE):
    # create the file to indicate rejection, or remove it
    if reject:
        reject_text = ("Scan run corresponding to this motion data is flagged for rejection. \n" +
                      "Motion file: %s\n" % data.inputname +
                      "Length: %d\n" % data.r +
                      "Points auto-censored:     %5d  Ratio auto-censored:     % 6.3f\n" % (data.censedn, data.censedr) +
                      "Points manually censored: %5d  Ratio manually censored: % 6.3f\n" % (data.censseries.count(0), data.censseries.count(0)/float(data.r)) +
                      "\n" +
                      "                          rRo   rPi   rYa   tSI   tLR   tPA\n" +
                      "Drift:                   %5.2f %5.2f %5.2f %5.2f %5.2f %5.2f\n" % tuple([data.maxdrift[i] for i in range(6)]) +
                      "Drift after auto-censor: %5.2f %5.2f %5.2f %5.2f %5.2f %5.2f\n" % tuple([data.maxdrift_c[i] for i in range(6)]) +
                      "Have a nice day!\n")
            
        try:
            rejectfile = open(data.rejectname, 'w')
            rejectfile.write(reject_text)
            rejectfile.close
            return True
        except:
            tkm.showwarning("Failed", "Couldn't create the flag file!  Check permissions?")
            return False
            
    else:
        try:
            os.remove(data.rejectname)
            return True
        except:
           tkm.showwarning("Failed", "Couldn't delete the flag file!  Check permissions?")
           return False
         
        

def calc_censor(mot, data):
    r=data.r
    # get the first-order difference along each column (result: (r-1) rows, 6 columns)
    # transpose it because for this purpose we're looking at each row all at once
    motdiff=zip(*diffbycol(mot))
    
    # now we have just the motion values in one array,
    # and just the difference values in another
    # set up the censor data to start
    censseries=[1 for i in range(r)]
    
    # now scan through from beginning to end, checking each point
    # to see if it's a spike.
    for i in range(r-1):
        # check the rotation values against the threshold
        maxrdiff = max(abs(k) for k in motdiff[i][0:3])
        if maxrdiff > data.options.rthresh:
            # slice index of first point to censor
            begc = max(0,(i + 1 - data.options.bskip))
            # slice index of last point to censor
            endc = min(r,(i + 1 + data.options.askip))
            # fill in the values
            #print "Rotation spike after TR %d, censor from %d to %d" % (i, begc, endc)
            for j in range(begc, endc): censseries[j] = 0
        
        # check the translation values against the threshold
        maxtdiff = max(abs(k) for k in motdiff[i][3:6])
        if maxtdiff > data.options.tthresh:
            # slice index of first point to censor
            begc = max(0,(i + 1 - data.options.bskip))
            # slice index of last point to censor
            endc = min(r,(i + 1 + data.options.askip))
            # fill in the values
            #print "Translation spike after TR %d, censor from %d to %d" % (i, begc, endc)
            for j in range(begc, endc): censseries[j] = 0
        
    # now we're done with "for i in range(r)" above.
    return censseries


def cleanup_zero_drifts(data):
    for i in range(6):
        if data.maxdrift[i] == 0: data.maxdrift[i] = 0.0001
        if data.maxdrift_c[i] == 0: data.maxdrift_c[i] = 0.0001
    
    
# A series of functions that duplicate numpy functionality

def shape(A):
    # This makes some assumptions which are probably only
    # valid for this application.  Namely, that all the
    # sequence types are iterable, and that all the sub-sequences
    # are of the same length.  Also, trying to apply this to a dynamic
    # object like a generator will probably work but will probably be 
    # computationally wasteful.
    if hasattr(A,'__iter__'):
        return (len(A),) + shape(A[0])
    else:
        return tuple()


def findall(L, value, start=0):
    i = start-1
    try:
        while 1:
            i = L.index(value, i+1)
            yield i
    except ValueError:
        pass
    


def load(filename):
    infile=open(filename,'r')
    return [[float(x) for x in row.split()] for row in infile.readlines()]


def save(filename, thedata, theformatstring='% 9.6f '):
    #writer=csv.writer(open(filename,'w'), delimiter
    outfile = open(filename,'w')
    for row in thedata:
        outfile.writelines(reduce(lambda x,y: x+y, [theformatstring % z for z in row]) + "\n")
    

def addeach(A, B):
    return map((lambda x,y: x+y), A, B)
    
def subtracteach(A, B):
    return map((lambda x,y: x-y), A, B)
    
def subtractbyrow(A, B):
    #A-B for, e.g. removing the 6 means in B from the 6 long columns of A
    return zip(*map(lambda x: subtracteach(x, B), zip(*A)))

def addbyrow(A, B):
    #A+B for, e.g. putting back the 6 means in B from the 6 long columns of A
    return zip(*map(lambda x: addeach(x, B), zip(*A)))

def smult(A, b):
    # multiply each element of list A by scalar b
    return map(lambda x: x * b, A)

def multeach(A, B):
    return map((lambda x,y: x*y), A, B)
    
def multeachbycol(A,B):
    return [multeach(A,x) for x in B]

def diff(A):
    return [A[i+1]-A[i] for i in range(len(A)-1)]
    
def diffbycol(A):
    return [diff(x) for x in A]
    
def mean(A):
    return sum(A)/float(len(A))

def meanbycol(A):
    return [mean(x) for x in A]

def sortbycol(A):
    return [sorted(x) for x in A]
    
def driftbycol(A):
    return [y[-1]-y[0] for y in [sorted(x) for x in A]]
    
def formatExceptionInfo(maxTBlevel=5):
    # this is just for debugging!
    cla, exc, trbk = sys.exc_info()
    excName = cla.__name__
    try:
        excArgs = exc.__dict__["args"]
    except KeyError:
        excArgs = "<no args>"
    excTb = traceback.format_tb(trbk, maxTBlevel)
    return (excName, excArgs, excTb)

###########################################################
#This does the graphing part.
###########################################################

class CensorUI (Frame):
    # Note the the proper functioning of many of these functions 
    # including: expandbutton, refresh_cens_graph, graph_cens, click_function, clear_graphs
    # is dependent on assumptions about the order the canvas items were created in.
    # vertical rectangles first, censor graph immediately next, motion graphs finally.
    
    def __init__(self, input_motion_data, input_center_data, data, parser, master=None):
        Frame.__init__(self, master)
        self.mot_data = input_motion_data
        self.cent_data = input_center_data
        self.scale_mode = 0
        self.plotscale = [0,0,0,0,0,0]
        self.pack()
        #master.lift()
        self.check_for_reject_flag(data, parser)
        self.createWidgets(data)
        self.display_drifts(data)
        self.show_censor_numbers(data)
        self.setup_rects(data)  # adds r canvas items
        self.graph_cens(data)   # adds r canvas items
        self.setup_grid(data)   # adds 6 + 6 canvas items (baselines & dividers)
        self.scale_all(data)
        self.graph_all(data)
        self.current_highlight = 0
        self.dragging = False
        self.dragval  = 0
        self.yes_save = True
        

    def test_function(self):
        print "self.mot_data ", type(self.mot_data), shape(self.mot_data)
        print "self.cent_data ", type(self.cent_data), shape(self.cent_data)
        
        
    def createWidgets(self, data):
        # a frame for the text and controls, will go on the left
        #self.controls = Frame(master=self, bd=3, relief=SUNKEN)
        self.controls = Frame(master=self)
        self.controls.pack(side=LEFT)
        
        # Done, confirm then write out and exit
        self.controls.donebutton = Button(self.controls, width=6, text="Done", command = self.donebutton)

        # Cancel, confirm then exit without writing anything out
        self.controls.cancelbutton = Button(self.controls, width=6, text="Cancel", command = self.cancelbutton)

        # Revert to un-edited censor
        self.controls.resetbutton = Button(self.controls, width=6, text="Reset", command = lambda: self.resetbutton(data))

        # Flag this subject for rejection
        if self.isrejected:
            self.controls.rejectbutton = Button(self.controls, width=6, text="Accept", command = lambda: self.rejectbutton(data))
        else:
            self.controls.rejectbutton = Button(self.controls, width=6, text="Reject", command = lambda: self.rejectbutton(data))

        # Expand the vertical scale of the motion graphs.
        self.controls.expandbutton = Button(self.controls, width=6, text="Scale 0", command = lambda: self.expandbutton2(data))

        # Display all graphs with the same scale.
        self.controls.sscalebutton = Button(self.controls, width=6, text="SameScal", command = lambda: self.sscalebutton(data))

        # this shows the current mouse position in TR
        self.controls.counter = Text(self.controls, height=1, width=9)
        
        # Show the current number of censored points
        self.controls.ncens_l = Text(self.controls, height=1, width=9)
        self.controls.ncens_l.insert(END, "#Censored")
        self.controls.ncens_l.config(state=DISABLED)
        self.controls.ncens = Text(self.controls, height=1, width=9)
        
        # Show the current ratio of censored points
        self.controls.rcens_l = Text(self.controls, height=1, width=9)
        self.controls.rcens_l.insert(END, "Ratio")
        self.controls.rcens_l.config(state=DISABLED)
        self.controls.rcens = Text(self.controls, height=1, width=9)
        
        # show the actual values (might add mean back in later)
        self.controls.valuelabel = Text(self.controls, height=1, width=9)
        #self.controls.valuelabel.tag_config("a", font="System 10")
        self.controls.valuelabel.insert(END, 'Values:')
        self.controls.valuelabel.config(state=DISABLED)
        self.controls.roll  = Text(self.controls, height=1, width=9)
        self.controls.pitch = Text(self.controls, height=1, width=9)
        self.controls.yaw   = Text(self.controls, height=1, width=9)
        self.controls.dS    = Text(self.controls, height=1, width=9)
        self.controls.dL    = Text(self.controls, height=1, width=9)
        self.controls.dP    = Text(self.controls, height=1, width=9)
        
        # show overall drift for each axis
        self.controls.blank  = Text(self.controls, height=1, width=9)
        self.controls.driftlabel = Text(self.controls, height=1, width=9)
        self.controls.driftlabel.insert(END, 'Drifts:')
        self.controls.driftlabel.config(state=DISABLED)
        self.controls.droll  = Text(self.controls, height=1, width=9)
        self.controls.dpitch = Text(self.controls, height=1, width=9)
        self.controls.dyaw   = Text(self.controls, height=1, width=9)
        self.controls.ddS    = Text(self.controls, height=1, width=9)
        self.controls.ddL    = Text(self.controls, height=1, width=9)
        self.controls.ddP    = Text(self.controls, height=1, width=9)
        
        # small canvas for axis scale marks
        if self.isrejected:
            self.axis = Canvas(self, bg='red', width=data.options.scalewidth, height=data.options.plotheight)
        else:
            self.axis = Canvas(self, bg='white', width=data.options.scalewidth, height=data.options.plotheight)
        
        # How big do we want main canvas to be?  This heuristic might be changed at some point.
        # this means: if num points is greater than x, then set width of element to y
        widths = ((0,6),(300,4),(450,2))
        for setting in widths:
            if data.r > setting[0]: data.dx = setting[1]
    
        data.plotwidth = data.r * data.dx
        #print "data.plotwidth: %d, data.options.plotheight: %d, dx: %d" % (data.plotwidth, data.options.plotheight, data.dx)
        self.canvas = Canvas(self, bg='white', width=data.plotwidth, height=data.options.plotheight, selectbackground="black")
        self.canvas.pack(side=RIGHT)
        self.canvas.bind("<Button-1>", lambda e: self.click_function(e, data))
        self.canvas.bind("<Motion>", lambda e: self.mouseMove(e, data))
        self.canvas.bind("<ButtonRelease-1>", lambda e: self.finishDrag(e, data))

        # massage the quirky TK "pack" geometry
        self.controls.donebutton.pack(side=TOP)
        self.controls.cancelbutton.pack(side=TOP)
        self.controls.resetbutton.pack(side=TOP)
        self.controls.rejectbutton.pack(side=TOP)
        self.controls.expandbutton.pack(side=TOP)
        self.controls.sscalebutton.pack(side=TOP)
        self.controls.counter.pack(side=TOP)
        self.controls.ncens_l.pack(side=TOP)
        self.controls.ncens.pack(side=TOP)
        self.controls.rcens_l.pack(side=TOP)
        self.controls.rcens.pack(side=TOP)
        
        self.controls.ddP.pack(side=BOTTOM)
        self.controls.ddL.pack(side=BOTTOM)
        self.controls.ddS.pack(side=BOTTOM)
        self.controls.dyaw.pack(side=BOTTOM)
        self.controls.dpitch.pack(side=BOTTOM)
        self.controls.droll.pack(side=BOTTOM)
        self.controls.driftlabel.pack(side=BOTTOM)
        self.controls.blank.pack(side=BOTTOM)
        self.controls.dP.pack(side=BOTTOM)
        self.controls.dL.pack(side=BOTTOM)
        self.controls.dS.pack(side=BOTTOM)
        self.controls.yaw.pack(side=BOTTOM)
        self.controls.pitch.pack(side=BOTTOM)
        self.controls.roll.pack(side=BOTTOM)
        self.controls.valuelabel.pack(side=BOTTOM)
        
        self.controls.pack(side=LEFT, fill=Y)
        self.axis.pack(side=LEFT)
        self.canvas.pack(side=RIGHT)


    
    def check_for_reject_flag(self, data, parser):
        if os.path.exists(data.rejectname):
            message=('This motion data has been flagged for rejection.  This is indicated by the presence of the file\n' + 
                data.rejectname + '\nIf you proceed, you can remove this flag by clicking the "Accept" button.  ' +
                'Do you wish to proceed?')
            if tkm.askyesno("Rejected!?!", message, icon="warning"):
                self.isrejected = True
            else:
                self.master.quit()
        else:
            self.isrejected = False


    def display_drifts(self, data):
        self.controls.droll.insert(END, data.maxdrift_c[0])
        self.controls.dpitch.insert(END, data.maxdrift_c[1])
        self.controls.dyaw.insert(END, data.maxdrift_c[2])
        self.controls.ddS.insert(END, data.maxdrift_c[3])
        self.controls.ddL.insert(END, data.maxdrift_c[4])
        self.controls.ddP.insert(END, data.maxdrift_c[5])
        
        self.controls.droll.config(state=DISABLED)
        self.controls.dpitch.config(state=DISABLED)
        self.controls.dyaw.config(state=DISABLED)
        self.controls.ddS.config(state=DISABLED)
        self.controls.ddL.config(state=DISABLED)
        self.controls.ddP.config(state=DISABLED)
        
        if data.maxdrift_c[0] > data.options.rdrift:
            self.controls.droll.config(bg="red")
        if data.maxdrift_c[1] > data.options.rdrift:
            self.controls.dpitch.config(bg="red")
        if data.maxdrift_c[2] > data.options.rdrift:
            self.controls.dyaw.config(bg="red")
        if data.maxdrift_c[3] > data.options.tdrift:
            self.controls.ddS.config(bg="red")
        if data.maxdrift_c[4] > data.options.tdrift:
            self.controls.ddL.config(bg="red")
        if data.maxdrift_c[5] > data.options.tdrift:
            self.controls.ddP.config(bg="red")
        

    def donebutton(self):
        if tkm.askyesno("Done", "Are you sure you want to quit and write out the censor file?"):
            self.yes_save = True
            self.master.quit()
    

    def cancelbutton(self):
        if tkm.askyesno("Cancel", "Are you sure you want to quit without saving?"):
            self.yes_save = False
            self.master.quit()
    

    def rejectbutton(self, data):
        if self.controls.rejectbutton.cget("text") == "Reject":
            if flag_for_rejection(data, True): 
                self.axis.config(bg="red")
                self.controls.rejectbutton.config(text="Accept")
        else:
            if flag_for_rejection(data, False):
                self.axis.config(bg="white")
                self.controls.rejectbutton.config(text="Reject")
        

    def resetbutton(self, data):
        if tkm.askyesno("Reset", "Are you sure you want to revert to the original censor file?"):
            data.censseries = list(deepcopy(data.censbackup))
            self.refresh_cens_graph(data)
            self.show_censor_numbers(data)


    def expandbutton2(self, data):
        self.scale_mode += 1
        if self.scale_mode >= data.options.num_scales: self.scale_mode = 0
        self.controls.expandbutton.config(text="Scale %d" % self.scale_mode)
        self.clear_graphs(data)
        self.scale_all(data)
        self.graph_all(data)
        #print "Scale ", self.scale_mode, self.plotscale
        

    def sscalebutton(self, data):
        if self.controls.sscalebutton.cget("text") == "SameScal":
            #print "Expand scale at the expense of showing big spikes"
            self.controls.sscalebutton.config(text="SepScale")
            self.clear_graphs(data)
            # redraw with same scale for each
            self.scale_all(data)
            self.graph_all(data)
        else:
            #print "Contract scale to show big spikes"
            self.controls.sscalebutton.config(text="SameScal")
            self.clear_graphs(data)
            # redraw with separately scaled y-axis for each
            self.scale_all(data)
            self.graph_all(data)
        #print "Scale ", self.scale_mode, self.plotscale
    

    def show_censor_numbers(self, data):
        n_censed=data.censseries.count(0)
        self.controls.ncens.delete(1.0, END)
        self.controls.ncens.insert(END, "%d" % n_censed)
        self.controls.rcens.delete(1.0, END)
        r_censed=(n_censed/float(len(data.censseries)))
        self.controls.rcens.insert(END, "%6.4f" % r_censed)
        if r_censed > data.options.maxcens:
            self.controls.ncens.config(bg="red")
            self.controls.rcens.config(bg="red")
        else:
            self.controls.ncens.config(bg="white")
            self.controls.rcens.config(bg="white")
            
    
    
    def refresh_cens_graph(self, data):
        for i in range(data.r):
            xy = self.getcensoval(i, data)
            self.canvas.coords(i+data.r+1, xy)
            if (1-data.censseries[i]):
                # highlight the censored area
                self.canvas.itemconfig((i+1), fill="#FF8888")
            else:
                self.canvas.itemconfig((i+1), fill="white")

    
    def getcensoval(self, i, data):
        x1 = i * data.dx + 1
        x2 = x1 + data.dx
        y1 = data.options.censbasepix - (data.censseries[i] * data.options.censheight)
        y2 = y1 - data.dx
        return (x1, y1, x2, y2)
            

    def getcensrect(self, i, data):
        x1 = i * data.dx + 1
        x2 = x1 + data.dx
        y1 = 1
        y2 = data.options.plotheight + 1
        return (x1, y1, x2, y2)
            

    def graph_cens(self, data):
        for i in range(data.r):
            self.canvas.create_rectangle(self.getcensoval(i, data), outline="", fill = "#FF0000")
            if 1-data.censseries[i]:
                self.canvas.itemconfig((i+1), fill="#FF8888")


    def setup_rects(self, data):
        for i in range(data.r):
            self.canvas.create_rectangle(self.getcensrect(i, data), outline="", fill="white")
            
    
    
    def click_function(self, event, data):
        x, y = event.x, event.y
        pointnum = min(max((x - 1)/data.dx, 0), data.r-1)
        #print "Current item: ", self.canvas.find_withtag("current"), "pointnum: ", pointnum, "x: ", x, "y: ", y
        data.censseries[pointnum] = 1 - data.censseries[pointnum]
        xy = self.getcensoval(pointnum, data)
        self.canvas.coords(pointnum+data.r+1, xy)
        if (1-data.censseries[pointnum]):
            # highlight the censored area
            self.canvas.itemconfig((pointnum+1), fill="#FF8888")
            # indicate that we're in the process of censoring
            self.dragging = True
            self.dragval = 0
        else:
            self.canvas.itemconfig((pointnum+1), fill="white")
            # indicate that we're in the process of un-censoring
            self.dragging = True
            self.dragval = 1
        
    
    def finishDrag(self, event, data):
        self.dragging = False
        self.show_censor_numbers(data)
        
    
    def mouseMove(self, event, data):
        x, y = event.x, event.y
        pointnum = min(max((x - 1)/data.dx, 0), data.r-1)
                
        # display the TR number (indexed from 1) that the mouse is currently over
        self.controls.counter.delete(1.0,END)
        self.controls.counter.insert(END, 'TR: %d' % (pointnum+1))
        # show the actual values
        self.controls.roll.delete (1.0,END)
        self.controls.roll.insert (END, 'rRo% 6.2f' % (self.mot_data[0][pointnum] + self.cent_data[0]))
        self.controls.pitch.delete(1.0,END)
        self.controls.pitch.insert(END, 'rPi% 6.2f' % (self.mot_data[1][pointnum] + self.cent_data[1]))
        self.controls.yaw.delete  (1.0,END)
        self.controls.yaw.insert  (END, 'rYa% 6.2f' % (self.mot_data[2][pointnum] + self.cent_data[2]))
        self.controls.dS.delete   (1.0,END)
        self.controls.dS.insert   (END, 'tSI% 6.2f' % (self.mot_data[3][pointnum] + self.cent_data[3]))
        self.controls.dL.delete   (1.0,END)
        self.controls.dL.insert   (END, 'tLR% 6.2f' % (self.mot_data[4][pointnum] + self.cent_data[4]))
        self.controls.dP.delete   (1.0,END)
        self.controls.dP.insert   (END, 'tPA% 6.2f' % (self.mot_data[5][pointnum] + self.cent_data[5]))

        if self.dragging:
            # Change everything we touch
            data.censseries[pointnum] = self.dragval
            xy = self.getcensoval(pointnum, data)
            self.canvas.coords(pointnum+data.r+1, xy)
            if (1-data.censseries[pointnum]):
                # highlight the censored area
                self.canvas.itemconfig((pointnum+1), fill="#FF8888")
                # indicate that we're in the process of censoring
                self.dragging = True
                self.dragval = 0
            else:
                # un-highlight the un-censored area
                self.canvas.itemconfig((pointnum+1), fill="white")
                # indicate that we're in the process of un-censoring
                self.dragging = True
                self.dragval = 1
        else:
            # We need to manually do the highlighting, because the built-in activefill functionality
            # was off by a pixel, annoyingly enough.
            # un-highlight previously highlighted rectangle
            if (1-data.censseries[self.current_highlight]):
                # un-highlight the censored area
                self.canvas.itemconfig((self.current_highlight+1), fill="#FF8888")
            else:
                # un-highlight the non-censored area
                self.canvas.itemconfig((self.current_highlight+1), fill="white")
            # highlight the current active highlight rectangle
            if (1-data.censseries[pointnum]):
                # highlight the censored area
                self.canvas.itemconfig((pointnum+1), fill="#FF0000")
            else:
                # highlight the non-censored area
                self.canvas.itemconfig((pointnum+1), fill="yellow")
            # record which one it was so we can un-highlight it at the next movement
            self.current_highlight = pointnum
        
    
    def setup_grid(self, data):
        for col in range(6):
            plotbase  = int((col)*data.options.plotheight/6.0 + data.options.plotheight/12.0)
            plotfence = int((col)*data.options.plotheight/6.0)
            self.canvas.create_line(0, int(plotbase), data.plotwidth, int(plotbase), dash=(1,2))
            self.canvas.create_line(0, plotfence, data.plotwidth, plotfence)


    def graph_all(self, data):
        self.plot_scales(data)
        for i in range(6): self.graphit(i, data)
    
    
    def graphit(self, col, data):
        # col is which column (i.e. which motion axis) we want to graph
        # fit_spikes is whether we scale to the range with or without fit_spikes
        plotbase = int((col)*data.options.plotheight/6.0 + data.options.plotheight/12.0)
        for i in range(data.r-1):
            x1 = int(i * data.dx + (data.dx/2) + 1)
            x2 = int(x1 + data.dx)
            y1 = int(plotbase - self.mot_data[col][i] * self.plotscale[col])
            y2 = int(plotbase - self.mot_data[col][i+1] * self.plotscale[col])
            self.canvas.create_line(x1, y1, x2, y2)


    def scale_all(self, data):
        self.plot_scales(data)
        for i in range(6): self.scaleit(i, data)
    
    
    def scaleit(self, col, data):
        # col is which column (i.e. which motion axis) we want to graph
        # fit_spikes is whether we scale to the range with or without fit_spikes
        scalenames = ["rRo", "rPi", "rYa", "tSI", "tLR", "tPA"]
        plotbase = int((col)*data.options.plotheight/6.0 + data.options.plotheight/12.0)
        plotfence = int((col)*data.options.plotheight/6.0)
        
        # Label each graph
        self.axis.create_text(data.options.scalewidth/2, plotfence + 10, text=scalenames[col], font="System 10")
            
        # draw the fence lines here too
        self.axis.create_line(0, plotfence, data.options.scalewidth, plotfence, width=2)

        # label the center value of the scale
        scaletext = "%0.2f" % self.cent_data[col]
        self.axis.create_text(data.options.scalewidth/2, plotbase, text=scaletext, font="System 8")
        
        # short tick marks for quarter-mm
        ticks = filter((lambda x: (abs(x) <= data.options.plotheight/12.0) & (x != 0)), [int(self.plotscale[col]*i/4.0) for i in range(-40, 41)])
        # medium tick marks for half-mm
        tickm = filter((lambda x: (abs(x) <= data.options.plotheight/12.0) & (x != 0)), [int(self.plotscale[col]*i/2.0) for i in range(-20, 21)])
        # long tick marks for mm
        tickl = filter((lambda x: (abs(x) <= data.options.plotheight/12.0) & (x != 0)), [int(self.plotscale[col]*i/1.0) for i in range(-10, 11)])
        #print "Graph: ", col, "Scale: ", plotscale, "ticks:", ticks, "tickl:", tickl
        
        # set the right end of the tick marks, same for all
        x2 = data.options.scalewidth
        # set the length of the short tick marks
        x1 = data.options.scalewidth - 2
        # only plot the short tick marks if there aren't too many of them
        if self.plotscale[col] > 9:
            for i in ticks:
                y = plotbase + i
                self.axis.create_line((x1, y, x2, y))
        # set the length of the medium tick marks
        x1 = data.options.scalewidth - 5
        for i in tickm:
            y  = plotbase + i
            self.axis.create_line((x1, y, x2, y))
        # set the length of the long tick marks
        x1 = data.options.scalewidth - 12
        for i in tickl:
            y  = plotbase + i
            self.axis.create_line((x1, y, x2, y))

        
    def plot_scales(self, data):
        if self.controls.sscalebutton.cget("text") == "SameScal":
            # this means we are in the state where separate scales are allowed
            if self.scale_mode == 0:
                # at mode zero, fit in the spikes, i.e. use data.maxdrift instead of data.maxdrift_c
                for i in range(6):  # do it separately for each one
                    self.plotscale[i] = (data.options.plotheight/6.0)/data.maxdrift[i]
                    self.plotscale[i] = min(self.plotscale[i], data.options.plotheight/6.0)
            else:
                # at modes > 0, ignore spikes, i.e. use data.maxdrift_c instead of data.maxdrift
                for i in range(6):  # do it separately for each one
                    scalescale = data.options.scale_each_click**(self.scale_mode-1)
                    self.plotscale[i] = scalescale*(data.options.plotheight/6.0)/data.maxdrift_c[i]
                    self.plotscale[i] = min(self.plotscale[i], data.options.plotheight/6.0)
                        
        else:
            # this means we are in the state where all plots are scaled the same
            # get the full maximum range of the largest rotation, including spikes
            maxrange = max(data.maxdrift[0:3])
            # calculate number of pixels per degree
            thescale = ((data.options.plotheight/6.0)/maxrange)*(data.options.scale_each_click**self.scale_mode)
            thescale = min(thescale, data.options.plotheight/6.0)
            # set all rotations to the same scale
            for i in range(3): self.plotscale[i] = thescale
            # get the full maximum range of the largest translation, including spikes
            maxrange = max(data.maxdrift[3:6])
            # calculate number of pixels per millimeter
            thescale = ((data.options.plotheight/6.0)/maxrange)*(data.options.scale_each_click**self.scale_mode)
            thescale = min(thescale, data.options.plotheight/6.0)
            # set all translations to the same scale
            for i in range(3): self.plotscale[i+3] = thescale
    # end plot_scales
        
        

    def clear_graphs(self, data):
        allitems=self.canvas.find_all()
        # identify the ones made after the vertical highlight rectangles and the censor graph
        graphitems=filter((lambda x: x>2*(data.r)+6+6), allitems)
        for x in graphitems: self.canvas.delete(x)
        # clear the tickmarks
        # for some reason this leaves the text alone, which is what I want.
        self.axis.delete(ALL)
        
    
    def mainloop(self):
        Frame.mainloop(self)
        return self.yes_save



def make_interactive_graphs(mot, cent, data, parser):        
    def quit_check():
        if tkm.askyesno("Done", "Are you sure you want to quit and write out the censor file?"):
            root.destroy()
            
    root=Tk()
    root.title("Censor %s" % data.inputname)
    root.protocol("WM_DELETE_WINDOW", quit_check)
    # create the UI object
    myUIobject = CensorUI(mot, cent, data, parser, root)
    
    # start the UI
    return myUIobject.mainloop()


def quit_check():
    if tkm.askyesno("Done", "Are you sure you want to quit and write out the censor file?"):
        root.destroy()

    
class Data:
    # This is just for making an object for holding the data.
    pass


###########################################################
#End of make_interactive_graphs(), the graphing part.
###########################################################


if __name__ == "__main__":
    main()
